{"meta":{"title":"区块链学习记录","subtitle":"区块链学习记录","description":"这是一个记录个人区块链学习的网站，不定期更新各种区块链技术文章，欢迎转载。","author":"Jeffrey Zhou","url":"http://zhouyasong.cn/blog"},"pages":[{"title":"tags","date":"2018-02-13T09:27:56.000Z","updated":"2018-02-13T09:44:37.919Z","comments":true,"path":"tags/index.html","permalink":"http://zhouyasong.cn/blog/tags/index.html","excerpt":"","text":"区块链智能合约跨链钱包"},{"title":"关于我","date":"2018-02-13T09:39:59.000Z","updated":"2018-02-13T09:43:45.976Z","comments":true,"path":"about/index.html","permalink":"http://zhouyasong.cn/blog/about/index.html","excerpt":"","text":"2015年开始接触区块链，参与过比原链开发。现在是在校本科三年级学生，创建这个博客的意义是为了记录自己的区块链学习笔记。"}],"posts":[{"title":"docker学习笔记","slug":"yaml学习笔记","date":"2018-07-19T14:41:48.000Z","updated":"2018-07-20T03:40:18.681Z","comments":true,"path":"2018/07/19/yaml学习笔记/","link":"","permalink":"http://zhouyasong.cn/blog/2018/07/19/yaml学习笔记/","excerpt":"yaml 学习基本语法规则yaml实质上是一种数据串行化格式： 大小写敏感 使用缩进表示层级关系 缩进时不允许使用Tab键，只允许使用空格。 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可 yaml支持三种数据结构： 对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary） 数组：一组按次序排列的值，又称为序列（sequence） / 列表（list） 纯量（scalars）：单个的、不可再分的值","text":"yaml 学习基本语法规则yaml实质上是一种数据串行化格式： 大小写敏感 使用缩进表示层级关系 缩进时不允许使用Tab键，只允许使用空格。 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可 yaml支持三种数据结构： 对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary） 数组：一组按次序排列的值，又称为序列（sequence） / 列表（list） 纯量（scalars）：单个的、不可再分的值 对象对象的一组键值对，使用冒号结构表示：1animal : pets 转换为javascript如下：1&#123;animal : &apos;pets&apos;&#125; yaml也支持另外一种写法，将所有键值对写成一个行内对象：1hash: &#123; name: Steve, foo: bar &#125; 转换为js如下：1&#123;hash: &#123;name: &apos;Steve&apos;, foo: &apos;bar&apos;&#125;&#125; 数组一组连词线开头的行，构成一个数组：123- Cat- Dog- Goldfish 转换为js如下：1[&apos;Cat&apos;, &apos;Dog&apos;, &apos;Goldfish&apos;] 数据结构的子成员是一个数组，则可以在该项下面缩进一个空格：1234- - Cat - Dog - Goldfish 转换为js如下：1[[&apos;Cat&apos;, &apos;Dog&apos;, &apos;Goldfish&apos;]] 数组也可以采用行内表示法：1animal: [Cat, Dog] 转换为js如下：1&#123;animal: [&apos;Cat&apos;, &apos;Dog&apos;]&#125; 复合结构对象和数组可以结合使用，形成复合结构。123456789languages: - Ruby - Perl - Python websites: YAML: yaml.org Ruby: ruby-lang.org Python: python.org Perl: use.perl.org 转化为js如下：123456&#123; languages: [Ruby, Perl, Python], wesites: &#123;YAML: &apos;yaml.org&apos;, Ruby: &apos;ruby-lang.org&apos;, Python: &apos;python.org&apos;, perl: &apos;use.perl.org&apos;&#125;&#125; 纯量纯量是最基本的，不可再分的值，以下都是js的纯量：1234567字符串 布尔值 isSet: true -&gt; &#123;isSet: true&#125;整数浮点数 number: 12.30 -&gt; &#123;number: 12.30&#125;Null parent: ~ -&gt; &#123;parent: null&#125;时间 iso8601: date -&gt; &#123;iso8601: new Date(date)&#125;日期 date: 1996-09-24 -&gt; &#123;date: new Date(&apos;1996-09-24&apos;)&#125; yaml 允许两个感叹号强制转换数据类型：12e: !!str 123f: !!str true 转换为js如下:1&#123;e: &apos;123&apos;, f: &apos;true&apos;&#125; 字符串字符串默认不使用引号表示：1str: 这是一行字符串 转换为js：1&#123;str: &apos;这是一行字符串&apos;&#125; 如果字符串中包含空格或者特殊符号，需要放在引号中：1str: &apos;内容：字符串&apos; 转换为js如下：1&#123;str: &apos;内容：字符串&apos;&#125; 单引号双引号都可以用，但是双引号不会对特殊字符转义：12str1: &apos;a\\nb&apos;str2: &quot;a\\nb&quot; 转换为js如下：1&#123;str1: &apos;a\\\\nb&apos;, str2: &quot;a\\nb&quot;&#125; 单引号中还有单引号，必须使用两个单引号进行转义：1str: &apos;Jeffrey&apos;&apos;s blog&apos; 转化为js如下：1&#123;str: &apos;Jeffrey\\&apos;s blog&#125; 字符串可以写成多行，从第二行开始需要有空格，换行符会被转换为空格：123str: Jeffrey bitcoin ethereum 转换为js如下：1&#123;str: Jeffrey bitcoin ethereum&#125; 多行字符串使用 | 保留换行符，使用&gt;折叠换行：123456this: | bitcoin ethereumthat: &gt; bitcoin ethereum 转换为js如下：1&#123;this: &apos;bitcoin\\nethereu\\n&apos;, that: &apos;bitcoin ethereum\\n&apos;&#125; + 表示保留文字段末尾的换行， `-`` 表示去除文字段末尾的换行123456789str1: | bitcoinstr2: |+ bitcoin str3: |- bitcoin 转化为js如下：1&#123;str1: &apos;bitcoin\\n&apos;, str2: `bitcoin\\n\\n\\n`, str3: `bitcoin`&#125; 字符串中可以插入html标记：12345message: | &lt;p style=&quot;color: red&quot;&gt; 段落 &lt;/p&gt; 转换为js如下:1&#123; message: &apos;\\n&lt;p style=&quot;color: red&quot;&gt;\\n 段落\\n&lt;/p&gt;\\n&apos; &#125; 引用&amp; 用来建立锚点，&lt;&lt; 表示合并到当前数据，* 用来引用锚点。1234567891011defaults: &amp;defaults adapter: postgres host: localhostdevelopment: database: myapp_development &lt;&lt;: *defaultstest: database: myapp_test &lt;&lt;: *defaults 等同于：12345678910111213defaults: adapter: postgres host: localhostdevelopment: database: myapp_development adapter: postgres host: localhosttest: database: myapp_test adapter: postgres host: localhost 举例：123456- &amp;showell Steve - Clark - Brian - Oren - *showell 转化为js如下：12[ &apos;Steve&apos;, &apos;Clark&apos;, &apos;Brian&apos;, &apos;Oren&apos;, &apos;Steve&apos; ] 函数和正则表达式的转换JS-YAML库特有的功能， 可以把函数和正则表达式转换成字符串：123# example.ymlfn: function () &#123; return 1 &#125;reg: /test/ 解析上面的 yml 文件的代码如下。1234567891011var yaml = require(&apos;js-yaml&apos;);var fs = require(&apos;fs&apos;);try &#123; var doc = yaml.load( fs.readFileSync(&apos;./example.yml&apos;, &apos;utf8&apos;) ); console.log(doc);&#125; catch (e) &#123; console.log(e);&#125; 从 JavaScript 对象还原到 yaml 文件的代码如下。1234567891011121314151617var yaml = require(&apos;js-yaml&apos;);var fs = require(&apos;fs&apos;);var obj = &#123; fn: function () &#123; return 1 &#125;, reg: /test/&#125;;try &#123; fs.writeFileSync( &apos;./example.yml&apos;, yaml.dump(obj), &apos;utf8&apos; );&#125; catch (e) &#123; console.log(e);&#125; TODO: 添加转换为go语言版本。","categories":[],"tags":[{"name":"yaml","slug":"yaml","permalink":"http://zhouyasong.cn/blog/tags/yaml/"}]},{"title":"docker学习笔记","slug":"docker学习笔记","date":"2018-07-19T14:41:48.000Z","updated":"2018-07-20T03:39:25.435Z","comments":true,"path":"2018/07/19/docker学习笔记/","link":"","permalink":"http://zhouyasong.cn/blog/2018/07/19/docker学习笔记/","excerpt":"基本概念 镜像 ： 一个特殊的文件系统，提供容器运行时所需的程序，库，资源，配置等文件，还包含运行时所准的的一些配置参数。 容器 ： 容器的实质是进程 仓库 ： &lt;仓库&gt;:&lt;标签&gt; Docker 命令详解docker命令格式: docker &lt;选项&gt;&lt;命令&gt;&lt;参数&gt; 选项12345-- config string //使用本地config文件 - D 启动debug模式- d 以守护模式运行- p 设置pid文件路径- v 打印版本信息","text":"基本概念 镜像 ： 一个特殊的文件系统，提供容器运行时所需的程序，库，资源，配置等文件，还包含运行时所准的的一些配置参数。 容器 ： 容器的实质是进程 仓库 ： &lt;仓库&gt;:&lt;标签&gt; Docker 命令详解docker命令格式: docker &lt;选项&gt;&lt;命令&gt;&lt;参数&gt; 选项12345-- config string //使用本地config文件 - D 启动debug模式- d 以守护模式运行- p 设置pid文件路径- v 打印版本信息 attach命令 attach命令用于将标准输入（stdin）与标准输出（stdout）连接到正在运行的容器 docker attach &lt;选项&gt;&lt;容器名称, id&gt; build 命令 build命令使用Dockerfile文件创建镜像 docker build &lt;选项&gt; 123456789--force-rm=false 创建镜像失败时，删除临时容器--no-cache=false 不使用之前构建中创建的缓存。-q、--quiet=false 不显示Dockerfile的RUN运行的输出结果--rm=true 创建镜像成功时，删除临时容器-t、--tag=&quot;&quot; 设置注册名称、镜像名称、标签。格式为 &lt;注册名称&gt;/&lt;镜像名称&gt;:&lt;标签&gt;（标签默认为latest） commit 命令 cp命令用于将容器的目录或文件复制的到主机。若将cp命令中的路径设置为目录，则将该目录下的所有内容复制到主机 docker cp &lt;容器名称&gt;:&lt;路径&gt;&lt;主机路径&gt; 1docker cp hello:/etc . 将容器内的整个/etc 目录复制到主机当前文件夹下 create 命令 create 命令使用指定的镜像创建容器。与run命令不同，使用create命令只能创建容器而并不启动 docker create &lt;选项&gt;&lt;镜像名称,id&gt;&lt;命令&gt;&lt;参数&gt; 12345678910111213-a 将标准输入、标准输出、标准错误链接到容器--attach=&quot;stdin&quot;--add-host=[] 向容器的/etc/hosts添加主机名与IP地址--add-host=hello:192.168.0.233-h 设置容器主机名--name 设置容器名称-i 激活标准输入-t 使用TTY模式（pseudo-TTY）-u 容器运行时需要使用liunx账户与uid-v 设置数据卷。设置要与主机共享目录，不将文件保存到容器，而直接保存到主机。在主机目录后添加 :ro、:rw进行读写设置，默认为:rw。 diff命令 diff命令用于检查容器文件系统的修改 docker diff &lt;容器名称，id&gt; 比较文件是否修改的标准是容器创建时的镜像内容 123A：添加的文件C：修改的文件D：删除的文件 events 命令 events命令用于实时输出Docker服务器中发生的事件 docker events 运行docker events命令，进入待机状态1docker events 在另一终端，运行容器1docker start hello #假设容器已存在 exec 命令 exec命令用于从外部运行容器内部的命令 docker exec&lt;选项&gt;&lt;容器名称，id&gt;&lt;命令&gt;&lt;参数&gt; 1234-d、--detach=false 以后台模式运行命令-i、--interactive=false 开启标准输入，即使未与容器连接，也维持标准输入-t、--tty=false 使用TTY模式（pseudo-TTY）若要使用bash，则必须设置该选项。若不设置该选项，则虽然输入命令，但不显示shell运行如下命令，创建 export 命令 export命令将用于将容器的文件系统导出为tar文件包 docker export &lt;容器名称，id&gt; 12$ docker run -it -d --name hello ubuntu /bin/bash$ docker export hello &gt; hello.tar history 命令 history 命令用于显示镜像的历史。此处的历史依据Dockerfile文件中的设置创建。 docker history &lt;选项&gt;&lt;镜像名称，id&gt; 12--no-trunc=false 输出所有因内容过长而省略的部分-q、--quiet=false 只显示镜像id images 命令 images命令用于输出镜像列表docker images &lt;选项&gt;&lt;镜像名称，id&gt; 123-a、--all=false 列出所有镜像，包括父镜像-f、--filter=[] 设置输出结果过滤。若设置为&quot;dangling=true&quot;，则只输出无名镜像--no-trunc=false 显示所有因内容过长而省略的部分 import 命令 import命令用于从压缩为tar文件（.tar .tar.gz .tgz .bzip .tar.xz .txz）的文件系统创建镜像 docker import &lt;注册名称&gt;/&lt;镜像名称&gt;:&lt;标签&gt; 1$ docker import http://example.com/hello.tar.zg hello info 命令 info命令用于显示当前系统信息、docker容器、镜像个数、设置等信息。 docker info inspect 命令 inspect 命令用于以JSON格式显示容器与镜像的详细信息 docker inspect &lt;选项&gt;&lt;容器或镜像名称，id&gt; kill 命令kill命令用于向容器发送KILL信号，从而关闭容器（推荐使用更优雅温和的 docker stop 命令) docker &lt;选项&gt;&lt;容器名称，id&gt; load 命令load命令用于从tar文件创建镜像 docker load &lt;选项&gt; 12$ docker save myimages &gt; myimages.tar #将已存在的镜像保存为tar文件$ docker load &lt; myimages.tar #在另一台电脑从tar文件创建镜像 login 命令 login命令用于登录Docker 的注册服务器 docker login &lt;选项&gt; logout 命令logout命令用于从Docker注册服务器中登出 docker logout &lt;选项&gt; logs 命令 logs命令用于输出容器日志 docker logs &lt;容器名称，id&gt; 123-f、--follow=false 一直输出实时日志-t、--timestamp=false 在登录时显示时间值--tail=&quot;all&quot; 指定数字，只从日志中输出一定个数 port 命令 port命令用于查看容器的某个端口是否处于开放状态 docker port &lt;容器名称，id&gt;&lt;端口&gt; pause 命令pause命令用于暂停容器中正在运行的所有进程 docker pause &lt;容器名称，id&gt; ps 命令 ps命令用于输出容器列表 docker ps &lt;选项&gt;12345-a、--all=false 列出所有容器。不带 -a 只输出在运行的容器--before=&quot;&quot; 列出特定容器创建前的容器，包含停止的容器。-f、--filter=[] 设置输出过滤。如 &quot;exited=0&quot;-l、--latest=false 列出最后创建的容器，包含停止的容器-q、--quiet=false 只输出容器的id push 命令 push命令用于将镜像推送到Docker注册服务器 docker push &lt;注册名&gt;/&lt;镜像名&gt;:&lt;标签&gt; restart 命令 restart命令用户重启容器 docker restart &lt;选项&gt;&lt;容器名称，id&gt; rm 命令 rm 命令用于删除容器 docker rm &lt;选项&gt;&lt;容器名称，id&gt; run 命令 rm 命令用于删除容器 docker rm &lt;选项&gt;&lt;容器名称，id&gt; save 命令save命令用于将镜像保存为tar包文件 docker save &lt;选项&gt;&lt;镜像名称&gt;:&lt;标签&gt; search 命令search命令用与在docker hub 中搜索镜像 docker search &lt;选项&gt;&lt;搜索词&gt; start 命令start命令用于启动容器 docker start &lt;选项&gt;&lt;容器名称，id&gt; tag 命令tag命令用于设置镜标签 docker tag &lt;选项&gt;&lt;镜像名称&gt;:&lt;标签&gt;&lt;注册地址，用户名&gt;/&lt;镜像名称&gt;:&lt;标签&gt; top 命令top命令用于显示容器中正在运行的进程信息 docker top &lt;容器名称，id&gt; unpause 命令unpause命令用于重启 pause 命令暂停的容器 docker unpause &lt;容器名称，id&gt; wait 命令 wait 命令等待容器终止，然后输出 Exit Code docker wait &lt;容器名称，id&gt;","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"http://zhouyasong.cn/blog/tags/docker/"}]},{"title":"区块链安全和升级","slug":"区块链安全和升级","date":"2018-02-11T11:05:19.000Z","updated":"2018-02-13T09:45:32.901Z","comments":true,"path":"2018/02/11/区块链安全和升级/","link":"","permalink":"http://zhouyasong.cn/blog/2018/02/11/区块链安全和升级/","excerpt":"最近以太坊Parity钱包发生15万个以太币被盗事件，比特币8月1日也面临着软硬分叉的选择。无论是漏洞还是版本升级引起的分叉，此时的区块链系统都面临着被攻击的危险。包括之前出现的DAO事件,交易所失窃事件，一系列的问题都让区块链参与者备受财务和精神损失。 据统计，即使是最安全的比特币区块链， 运行过程都大概出现了22次BUG，软件系统产生问题不可避免，但如何让故障概率降到最小，同时在故障生产时如何快速隔离问题，这是每个区块链的设计和开发者需要认真考虑。 本文对历史上出现的重要一些漏洞进行案例分析，归纳出一些方法。比原链类似比特币采用UTXO和POW共识模型，又加入了图灵完备的智能合约系统，研究历史的教训对我们大有裨益， 当然也希望其他链的开发者在设计自己的区块链可以避免出现类似的漏洞，以及可以安全地进行版本升级。","text":"最近以太坊Parity钱包发生15万个以太币被盗事件，比特币8月1日也面临着软硬分叉的选择。无论是漏洞还是版本升级引起的分叉，此时的区块链系统都面临着被攻击的危险。包括之前出现的DAO事件,交易所失窃事件，一系列的问题都让区块链参与者备受财务和精神损失。 据统计，即使是最安全的比特币区块链， 运行过程都大概出现了22次BUG，软件系统产生问题不可避免，但如何让故障概率降到最小，同时在故障生产时如何快速隔离问题，这是每个区块链的设计和开发者需要认真考虑。 本文对历史上出现的重要一些漏洞进行案例分析，归纳出一些方法。比原链类似比特币采用UTXO和POW共识模型，又加入了图灵完备的智能合约系统，研究历史的教训对我们大有裨益， 当然也希望其他链的开发者在设计自己的区块链可以避免出现类似的漏洞，以及可以安全地进行版本升级。 比特币的交易数据结构是由很多脚本操作码构成的，攻击者可以设计多种交易结构类型使用这些操作码对节点进行拒绝服务攻击比如0.3.5版本之前的比特币系统允许攻击者使用OP_LSHIFT脚本进行拒绝服务攻击。1234567switch (opcode) ...... case OP_LSHIFT: if (bn2 &lt; bnZero) return false; bn = bn1 &lt;&lt; bn2.getulong(); break; 这是0.3.2版本中script.cpp中描述OP_LSHIFT的代码。OP_LSHIFT是一个数值运算的操作码，功能是bn2.getulong()左移bn1位并保留符号位得到bn。攻击者可能采用位运算让输出溢出的方式使CPU崩溃，从而达到拒绝服务攻击的效果。12345678910111213141516if (opcode == OP_CAT || opcode == OP_SUBSTR || opcode == OP_LEFT || opcode == OP_RIGHT || opcode == OP_INVERT || opcode == OP_AND || opcode == OP_OR || opcode == OP_XOR || opcode == OP_2MUL || opcode == OP_2DIV || opcode == OP_MUL || opcode == OP_DIV || opcode == OP_MOD || opcode == OP_LSHIFT || opcode == OP_RSHIFT)return false; // Disabled opcodes. 这是0.3.5以后版本中script.cpp描述OP_LSHIFT的代码。OP_LSHIFT已经直接被禁用。可以看到OP_LSHIFT等脚本操作码只是被禁用，并没有直接从代码里删除，如果想要重新启用这些脚本，就需要一次硬分叉。 另外，在#71036中区块发现了几个OP_CHECKSIG，这种命令会使节点做很多不必要的操作。1mTemplates.insert(make_pair(TX_PUBKEYHASH, CScript() &lt;&lt; OP_DUP &lt;&lt; OP_HASH160 &lt;&lt; OP_PUBKEYHASH &lt;&lt; OP_EQUALVERIFY &lt;&lt; OP_CHECKSIG)); 这是0.3.2版本中OP_CHECK是加密脚本，整个交易的输入、输出、脚本（从最近执行OP_CODESEPARATOR）都要哈希。所以当一个交易里面有几个OP_CHECKSIG的时候，会使交易进行重复哈希，有可能引起内存消耗过大甚至直接挂起，从而达到拒绝服务攻击的效果。1234567891011121314151617bool CScriptCompressor::IsToPubKey(std::vector&lt;unsigned char&gt; &amp;pubkey) const&#123; if (script.size() == 35 &amp;&amp; script[0] == 33 &amp;&amp; script[34] == OP_CHECKSIG &amp;&amp; (script[1] == 0x02 || script[1] == 0x03)) &#123; pubkey.resize(33); memcpy(&amp;pubkey[0], &amp;script[1], 33); return true; &#125; if (script.size() == 67 &amp;&amp; script[0] == 65 &amp;&amp; script[66] == OP_CHECKSIG &amp;&amp; script[1] == 0x04) &#123; pubkey.resize(65); memcpy(&amp;pubkey[0], &amp;script[1], 65); CKey key; return (key.SetPubKey(CPubKey(pubkey))); // SetPubKey fails if this is not a valid public key, a case that would not be compressible &#125; return false;&#125; 0.8版本对OP_CHECKSIG进行了限制，在这部分代码中首先匹配各脚本命令所占字节和所在位置，如果不正确，就不会继续执行压缩交易。 参数的限制不明确与使用不规范也能引发漏洞在#74638区块中，攻击者在交易中产生了超过184亿比特币，并发送到网络上的两个地址。几个小时之内，在修复错误后，交易记录被从事务日志中删除，并将网络分配到比特币协议的更新版本。这是在比特币历史上发现和利用的唯一重大安全漏洞。 12345678910&quot;out&quot; : [ &#123; &quot;value&quot; : 92233720368.54277039, &quot;scriptPubKey&quot; : &quot;OP_DUP OP_HASH160 0xB7A73EB128D7EA3D388DB12418302A1CBAD5E890 OP_EQUALVERIFY OP_CHECKSIG&quot; &#125;, &#123; &quot;value&quot; : 92233720368.54277039, &quot;scriptPubKey&quot; : &quot;OP_DUP OP_HASH160 0x151275508C66F89DEC2C5F43B6F9CBE0B5C4722C OP_EQUALVERIFY OP_CHECKSIG&quot; &#125; ] 上述输出产生两个90多亿的比特币原理如下：比特币只检查UTXO的输入是否大于等于输出，如果大于等于交易就成立。in： 0.50 BTCout：92233720368.54277039，92233720368.54277039fee：0.5192233720368.54277039+92233720368.54277039= -0.01两个90多亿的19位双精度浮点数相加等于-0.01。所以这笔交易通过了。 此外，0.7.2版本以前,攻击者可以发送一系列的消息包含一个整数整除0在Bloom Filter处理代码，这是对参数使用不规范导致可以远程导致Bitcoin-qt和bitcoind崩溃。 私钥是比特币最重要的组成部分之一在0.4.1-0.5.0版本中比特币私钥并没有被加密，dat文件被加密。比特币私钥有可能被盗走。问题在于管理比特币私钥的是BSDDB数据库引擎。当你使用数据库删除某一数据的时候，他只是标记这个数据被删除了，而不是把数据域。新生成的bat文件也只是追加到数据的后面，而不是覆盖。 攻击者还可以通过网络对比特币节点进行网络攻击0.7.0版本，比特币协议有一个预警系统，用来传播关于数字货币的重要新闻。对于收到的每个警报，节点都会检查警报签名。每一项检查都需要一段时间，通常在1到4秒之间。验证时间并不取决于签名的正确性。因此，攻击者可能会在不付出代价的时候向节点注入无效的警报，并耗尽受害者的节点CPU。 如果一个恶意节点发送以每秒3000次警报每秒64Kb的频率向受害节点发送警报，会使受害节点的CPU消耗100%去关联 ThreadMessageHandler2()线程。 即使是发送正确警报的节点，在64字节/秒的连接上连续发送一个188字节的正确警告仍然会使受害者的CPU使用率上升到100%。 解决办法： 断开任何发送坏警报节点的网络连接 检查一个警告是否有超过一次的验证，超过一次的警告就直接拒绝1234567891011121314151617181920212223242526272829303132void ThreadMessageHandler2(void* parg)&#123; printf(&quot;ThreadMessageHandler started\\n&quot;);#ifdef __WXMSW__ SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_BELOW_NORMAL);#else setpriority(PRIO_PROCESS, getpid(), PRIO_MIN);#endif loop &#123; // Poll the connected nodes for messages vector&lt;CNode*&gt; vNodesCopy; CRITICAL_BLOCK(cs_vNodes) vNodesCopy = vNodes; foreach(CNode* pnode, vNodesCopy) &#123; pnode-&gt;AddRef(); // Receive messages TRY_CRITICAL_BLOCK(pnode-&gt;cs_vRecv) ProcessMessages(pnode); // Send messages TRY_CRITICAL_BLOCK(pnode-&gt;cs_vSend) SendMessages(pnode); pnode-&gt;Release(); &#125; // Wait and allow messages to bunch up vnThreadsRunning[2]--; Sleep(100); vnThreadsRunning[2]++; if (CheckForShutdown(2)) return; &#125;&#125; 可以看到检查时间并不取决于警报的正确性，只要调用ThreadMessageHandler2线程就会sleep(100)。 合约型区块链更复杂，漏洞出现的几率也更大以以太坊为例，以太坊区块链账户模型是account模型，因为具有图灵完备的智能合约系统，实现起来比比特币更复杂，使得在以太坊上出现的很多智能合约都存在漏洞。The DAO 和前几天出现的Parity钱包漏洞就是很好的例子。下面主要分析一下Parity钱包漏洞。 Parity Multisig电子钱包版本1.5+的漏洞被发现，使得攻击者从三个高安全的多重签名合约中窃取到超过15万ETH（约3000万美元）。攻击原理如下： 成为合约的owner123456function() payable&#123; if(msg.value &gt; 0) Deposit(msg.sender,msg.value); else if(msg.data.length &gt; 0) _walletLibrary.delegatecall(msg.data);&#125; 通过往这个合约地址转账一个value = 0 ,msg.data.length &gt; 0 的交易， 执行到_walletLibrary.delegatecall的分支，该函数能无条件的调用合约内的任何一个函数，黑客调用了一个叫做 initWallet的函数：1234function initWallet(address [] _owners,uint _required,uint _daylimit)&#123; initDayLimit(_daylimit); initMultiowned(_owners,_required);&#125; 这个函数再次调用initMultiowned函数：1234567891011function initMultiowned(address [] _owners,uint _required)&#123; m_numOwners = _owners.length + 1; m_owners[1] = uint(msg.sender) m_ownerIndex[uint(msg.sender)] = 1; for(uint i=0;i&lt;_owners.length;++i) &#123; m_owners[2+i]=uint(_owners[i]); m_ownerIndex[uint(_owners[i])] = 2+i; &#125; m_required = _required;&#125; 但是，initWallet没有检查以防止攻击者在合同初始化后调用到initMultiowned, 这个函数使得这个合约的所有者被改为攻击者。 在parity钱包源代码里修改漏洞的时候仅仅改了一个词，把权限问题划分清楚。12- function initDaylimit(uint _limit) internal + function initDaylimit(uint _limit) only_uninitialized 由此我们可以看到使用图灵完备的智能合约系统时一定要注意合约之间、合约的函数之间相互调用时产生的权限和逻辑问题。 除了软件代码本身的问题和由攻击者主动发起的攻击之外，区块链系统在版本升级时也会遇到很多问题0.3.13版本，比特币进行了版本升级，每笔交易都要有0.01的比特币的交易费，导致了很多微小交易没人打包变成了无效的交易，这些无效的交易放在钱包里可能被继续交易而一直没有被确认。比特币开发者又更改了版本，小额交易（t&lt;0.01）不需要支付交易费。 此外，版本升级还会引起重复验证交易，可能会存在一种处理重复交易的攻击方式。 存在重复验证交易可能会有两种形式，一是故意添加进来的重复交易。二是版本升级时旧区块与新区块产生重复交易。比如一条交易信息广播出来，新旧两个版本的客户端分别使用新旧两个版本号打包交易，当验证交易的时候，同一个交易的UTXO就会被查找两次，很有可能造成双重支付攻击。BIP30已经解决，在同一条链中，不允许已经验证的交易的标识符与以前的、未完全花费的标识符匹配。只有当前交易的前一个交易没有可输出的输出时，重复交易才可被使用。 总结与相关建议从上面的分析我们可以看到，区块链也避免不了没有漏洞、不受攻击。当出现漏洞需要修补漏洞和提升性能的时候，就需要进行软件升级，说到版本升级就必须说一下软分叉和硬分叉的区别 。 区块链升级伴随着新的版本号的出现，区块数据格式和交易的数据格式都会更换新的版本号，升级软件的矿工可以不接受旧版本号的交易消息，没有升级软件的矿工接收新版本号的交易消息可以称为软分叉，软分叉最终会达成新版本号一致，硬分叉就是一刀切，升级软件的矿工不接受旧的版本号的消息，没有升级软件的矿工不接受新的版本号的交易消息。 软硬分叉可以用这两个公式来表示： 软分叉：a = 1; a = 1+2; a = 2; 硬分叉：a =1 ; a = 2; 版本升级时需要考虑的问题： 考虑大部分网络支持规则之前/之后运行的旧/新软件的所有四种组合 考虑与老客户/矿工的向后兼容 在主网部署之前先在测试网络上可用 逐步推出变革，一步一步来 升级流程建议 不接受非标准的交易到内存池，如果它有一个未知的版本号 使用代码对过去1000个区块的版本号进行计数 如果最近的区块有55%或更多的版本号有未知版本号，则警告用户需要升级 升级的方案说明如何以最小化风险和中断的方式处理未来升级的可能性 必须设计操作码以便有任何一个交易不通过时都可视为无操作。当攻击者根据新规则进行有效的新交易攻击时，对旧的矿工/客户端无效，导致块分裂 使用新操作码的交易将被给予新版本号 运行新代码的矿工产生具有新版本号的块，因此可以测量对新功能的支持 较旧的节点不会中继或挖掘新的交易，也不会占用新交易的交易 比特币bug总结 Parity多重签名钱包被盗事件之技术分析 Blockchain Rule Update Process","categories":[],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://zhouyasong.cn/blog/tags/区块链/"}]}]}